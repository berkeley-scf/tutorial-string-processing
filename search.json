[
  {
    "objectID": "text-manipulation.html",
    "href": "text-manipulation.html",
    "title": "Basic text manipulation in R and Python",
    "section": "",
    "text": "Text manipulations in R, Python, Perl, and bash have a number of things in common, as many of these evolved from UNIX. When I use the term string here, I’ll be referring to any sequence of characters that may include numbers, white space, and special characters. Note that in R a character vector is a vector of one or more such strings.\nSome of the basic things we need to do are paste/concatenate strings together, split strings apart, take subsets of strings, and replace characters within strings. Often these operations are done based on patterns rather than a fixed string sequence. This involves the use of regular expressions.",
    "crumbs": [
      "Basic Text Manipulation"
    ]
  },
  {
    "objectID": "text-manipulation.html#overview",
    "href": "text-manipulation.html#overview",
    "title": "Basic text manipulation in R and Python",
    "section": "",
    "text": "Text manipulations in R, Python, Perl, and bash have a number of things in common, as many of these evolved from UNIX. When I use the term string here, I’ll be referring to any sequence of characters that may include numbers, white space, and special characters. Note that in R a character vector is a vector of one or more such strings.\nSome of the basic things we need to do are paste/concatenate strings together, split strings apart, take subsets of strings, and replace characters within strings. Often these operations are done based on patterns rather than a fixed string sequence. This involves the use of regular expressions.",
    "crumbs": [
      "Basic Text Manipulation"
    ]
  },
  {
    "objectID": "text-manipulation.html#r",
    "href": "text-manipulation.html#r",
    "title": "Basic text manipulation in R and Python",
    "section": "2 R",
    "text": "2 R\nIn general, strings in R are stored in character vectors. R’s functions for string manipulation are fully vectorized and will work on all of the strings in a vector at once.\nOne can do string manipulation in base R or using the stringr package. In general, I’d suggest using stringr functionsin place of R’s base string functions.\n\n2.1 String manipulation in base R\nA few of the basic R functions for manipulating strings are paste, strsplit, and substring. paste and strsplit are basically inverses of each other:\n\npaste concatenates together an arbitrary set of strings (or a vector, if using the collapse argument) with a user-specified separator character\nstrsplit splits apart based on a delimiter/separator\nsubstring splits apart the elements of a character vector based on fixed widths\nnchar returns the number of characters in a string.\n\nNote that all of these operate in a vectorized fashion.\n\nout &lt;- paste(\"My\", \"name\", \"is\", \"Chris\", \".\", sep = \" \")\npaste(c(\"My\", \"name\", \"is\", \"Chris\", \".\"), collapse = \" \") # equivalent\n\n[1] \"My name is Chris .\"\n\nnchar(out)\n\n[1] 18\n\nstrsplit(out, split = ' ')\n\n[[1]]\n[1] \"My\"    \"name\"  \"is\"    \"Chris\" \".\"    \n\n\n\n\n\n\n\n\nWarning\n\n\n\nSome string processing functions (such as strsplit above) can return multiple values for each input string (each element of the character vector). As a result, the functions will return a list, which will be a list with one element when the function operates on a single string.\n\nout &lt;- c(\"Her name is Maya\", \"Hello everyone\")\nstrsplit(out, split = ' ')\n\n[[1]]\n[1] \"Her\"  \"name\" \"is\"   \"Maya\"\n\n[[2]]\n[1] \"Hello\"    \"everyone\"\n\n\n\n\nHere are some examples of using substring:\n\ntimes &lt;- c(\"04:18:04\", \"12:12:53\", \"13:47:00\")\nsubstring(times, 7, 8)\n\n[1] \"04\" \"53\" \"00\"\n\n\n\nsubstring(times[3], 1, 2) &lt;- '01'   ## replacement\ntimes\n\n[1] \"04:18:04\" \"12:12:53\" \"01:47:00\"\n\n\nTo identify particular subsequences in strings, there are several closely-related R functions. grep will look for a specified string within an R character vector and report back indices identifying the elements of the vector in which the string was found. Note that using the fixed=TRUE argument ensures that regular expressions are NOT used. gregexpr will indicate the position in each string that the specified string is found (use regexpr if you only want the first occurrence). gsub can be used to replace a specified string with a replacement string (use sub if you only want to replace only the first occurrence).\n\ndates &lt;- c(\"2016-08-03\", \"2007-09-05\", \"2016-01-02\")\ngrep(\"2016\", dates)\n\n[1] 1 3\n\n\n\ngregexpr(\"2016\", dates)\n\n[[1]]\n[1] 1\nattr(,\"match.length\")\n[1] 4\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[2]]\n[1] -1\nattr(,\"match.length\")\n[1] -1\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n[[3]]\n[1] 1\nattr(,\"match.length\")\n[1] 4\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n\n\n\ngsub(\"2016\", \"16\", dates)\n\n[1] \"16-08-03\"   \"2007-09-05\" \"16-01-02\"  \n\n\n\n\n2.2 String manipulation using stringr\nThe stringr package wraps the various core string manipulation functions to provide a common interface. It also removes some of the clunkiness involved in some of the string operations with the base string functions, such as having to to call gregexpr and then regmatches to pull out the matched strings.\nHere’s a cheatsheet from RStudio on manipulating strings using the stringr package in R.\nFirst let’s see stringr’s versions of some of the base R string functions mentioned in the previous section.\nThe basic interface to stringr functions is function(character_vector, pattern, [replacement]).\nTable 1 provides an overview of the key functions related to working with patterns, which are basically wrappers for grep, gsub, gregexpr, etc.\n\n\n\n\n\n\n\nFunction\nWhat it does\n\n\n\n\nstr_detect\ndetects pattern, returning TRUE/FALSE\n\n\nstr_count\ncounts matches\n\n\nstr_locate/str_locate_all\ndetects pattern, returning positions of matching characters\n\n\nstr_extract/str_extract_all\ndetects pattern, returning matches\n\n\nstr_replace/str_replace_all\ndetects pattern and replaces matches\n\n\n\nThe analog of regexpr vs. gregexpr and sub vs. gsub is that most of the functions have versions that return all the matches, not just the first match, e.g., str_locate_all, str_extract_all, etc. Note that the _all functions return lists while the non-_all functions return vectors.\nTo specify options, you can wrap these functions around the pattern argument: fixed(pattern, ignore_case) and regex(pattern, ignore_case). The default is regex, so you only need to specify that if you also want to specify additional arguments, such as ignore_case or others listed under help(regex) (invoke the help after loading stringr)\nHere’s an example:\n\nlibrary(stringr)\nstr &lt;- c(\"Apple Computer\", \"IBM\", \"Apple apps\")\n\nstr_detect(str, fixed(\"app\", ignore_case = TRUE))\n\n[1]  TRUE FALSE  TRUE\n\nstr_count(str, fixed(\"app\", ignore_case = TRUE))\n\n[1] 1 0 2\n\n\n\nstr_locate(str, fixed(\"app\", ignore_case = TRUE))\n\n     start end\n[1,]     1   3\n[2,]    NA  NA\n[3,]     1   3\n\nstr_locate_all(str, fixed(\"app\", ignore_case = TRUE))\n\n[[1]]\n     start end\n[1,]     1   3\n\n[[2]]\n     start end\n\n[[3]]\n     start end\n[1,]     1   3\n[2,]     7   9\n\n\n\ndates &lt;- c(\"2016-08-03\", \"2007-09-05\", \"2016-01-02\")\nstr_locate(dates, \"20[^0][0-9]\") ## regular expression: years begin in 2010\n\n     start end\n[1,]     1   4\n[2,]    NA  NA\n[3,]     1   4\n\n\n\nstr_extract_all(dates, \"20[^0][0-9]\")\n\n[[1]]\n[1] \"2016\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"2016\"\n\nstr_replace_all(dates, \"20[^0][0-9]\", \"XXXX\")\n\n[1] \"XXXX-08-03\" \"2007-09-05\" \"XXXX-01-02\"",
    "crumbs": [
      "Basic Text Manipulation"
    ]
  },
  {
    "objectID": "text-manipulation.html#python",
    "href": "text-manipulation.html#python",
    "title": "Basic text manipulation in R and Python",
    "section": "3 Python",
    "text": "3 Python\nLet’s see basic concatenation, splitting, working with substrings, and searching/replacing substrings. Notice that Python’s string functionality is object-oriented (though len is not).\nHere, we’ll just cover the basic methods for the str type. There’s lots of additional functionality for working with strings using regular expressions in the re package. Of course in many cases of working with strings, one would need the full power of regular expressions to do what one needs to do.\nFirst let’s look at combining/concatenating strings. We can do this with the + operator or using the join method, which is (perhaps confusingly) called based on the separator of interest with the input strings as arguments.\n\nout = \"My\" + \"name\" + \"is\" + \"Chris\" +  \".\"\nout\n\n'MynameisChris.'\n\n\n\nout = ' '.join((\"My\", \"name\", \"is\", \"Chris\", \".\"))\nout\n\n'My name is Chris .'\n\n\nlen simply returns the number of characters in the string.\n\nlen(out) \n\n18\n\n\n\nout.split(' ')\n\n['My', 'name', 'is', 'Chris', '.']\n\n\nTo see the various string methods, we can hit tab after typing str. or based on any specific string:\n\nout.\n\nout.capitalize()    out.index(          out.isspace()       out.removesuffix(   out.startswith(\nout.casefold()      out.isalnum()       out.istitle()       out.replace(        out.strip(\nout.center(         out.isalpha()       out.isupper()       out.rfind(          out.swapcase()\nout.count(          out.isascii()       out.join(           out.rindex(         out.title()\nout.encode(         out.isdecimal()     out.ljust(          out.rjust(          out.translate(\nout.endswith(       out.isdigit()       out.lower()         out.rpartition(     out.upper()\nout.expandtabs(     out.isidentifier()  out.lstrip(         out.rsplit(         out.zfill(\nout.find(           out.islower()       out.maketrans(      out.rstrip(         \nout.format(         out.isnumeric()     out.partition(      out.split(          \nout.format_map(     out.isprintable()   out.removeprefix(   out.splitlines(     \nUnlike in R, you cannot use the string methods directly on a list or tuple of strings, but you of course can do things like list comprehension to easily process multiple strings.\nWorking with substrings relies on the fact that Python works with strings as if they are vectors of individual characters.\n\nvar = \"13:47:00\"\nvar[3:5]\n\n'47'\n\n\nHowever strings are immutable - you cannot alter a subset of characters in the string. Another option is to work with strings as lists.\n\nvar[0:2] = \"01\"\n\nTypeError: 'str' object does not support item assignment\n\n\nNow let’s consider finding substrings. Here Python tells us that ‘2016’ starts in the 6th position in the first and third elements (with 0-based indexing).\n\nvar = \"08-03-2016\"\nvar.find(\"2016\")\n\n6\n\n\nWe can count occurrences with .count():\n\nvar = \"08-03-2016; 07-09-2016\"\nvar.count(\"2016\")\n\n2\n\n\nAnd we can replace like this:\n\nvar = \"13:47:00\"\nvar.replace(\"13\", \"01\")\n\n'01:47:00'",
    "crumbs": [
      "Basic Text Manipulation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "String processing",
    "section": "",
    "text": "This tutorial covers tools for manipulating text data in R and Python, including the use of regular expressions. The tutorial is somewhat more focused on R than Python. Please click on the links on the left the various sections of this tutorial.\nPlease see the side menu bar for the various sections of this tutorial, of which this document is the introduction.\nIf you have a standard R or Python installation and can install the stringr package for R and the re package for Python, you should be able to reproduce the results in this document.\nThis tutorial assumes you have a working knowledge of R or Python.\nMaterials for this tutorial, including the Markdown file that was used to create this document are available on GitHub.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "regex.html",
    "href": "regex.html",
    "title": "Using regular expression in R and Python",
    "section": "",
    "text": "Regular expressions are a domain-specific language for finding patterns and are one of the key functionalities in scripting languages such as Perl and Python, as well as the UNIX utilities grep, sed, and awk.\nThe basic idea of regular expressions is that they allow us to find matches of strings or patterns in strings, as well as do substitution. Regular expressions are good for tasks such as:\n\nextracting pieces of text;\ncreating variables from information found in text;\ncleaning and transforming text into a uniform format; and\nmining text by treating documents as data.",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#overview",
    "href": "regex.html#overview",
    "title": "Using regular expression in R and Python",
    "section": "",
    "text": "Regular expressions are a domain-specific language for finding patterns and are one of the key functionalities in scripting languages such as Perl and Python, as well as the UNIX utilities grep, sed, and awk.\nThe basic idea of regular expressions is that they allow us to find matches of strings or patterns in strings, as well as do substitution. Regular expressions are good for tasks such as:\n\nextracting pieces of text;\ncreating variables from information found in text;\ncleaning and transforming text into a uniform format; and\nmining text by treating documents as data.",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#regular-expression-syntax",
    "href": "regex.html#regular-expression-syntax",
    "title": "Using regular expression in R and Python",
    "section": "2 Regular expression syntax",
    "text": "2 Regular expression syntax\nPlease use one or more of the following resources to learn regular expression syntax.\n\nOur tutorial on using the bash shell\nDuncan Temple Lang (UC Davis Statistics) has written a nice tutorial that is part of the repository for this tutorial\nCheck out Sections 9.9 and 11 of Paul Murrell’s book\n\nAlso, see the back/second page of RStudio’s stringr cheatsheet for a cheatsheet on regular expressions for a regular expression cheatsheet. And here is a website where you can interactively test regular expressions on example strings.",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#versions-of-regular-expressions",
    "href": "regex.html#versions-of-regular-expressions",
    "title": "Using regular expression in R and Python",
    "section": "3 Versions of regular expressions",
    "text": "3 Versions of regular expressions\nOne thing that can cause headaches is differences in version of regular expression syntax used. As discussed in man grep, extended regular expressions are standard, with basic regular expressions providing somewhat less functionality and Perl regular expressions additional functionality. In R, stringr provides ICU regular expressions (see help(regex)), which are based on Perl regular expressions. More details can be found in the regex Wikipedia page.\nThe bash shell tutorial provides a full documentation of the various extended regular expressions syntax, which we’ll focus on here. This should be sufficient for most usage and should be usable in R and Python, but if you notice something funny going on, it might be due to differences between the regular expressions versions.",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#general-principles-for-working-with-regex",
    "href": "regex.html#general-principles-for-working-with-regex",
    "title": "Using regular expression in R and Python",
    "section": "4 General principles for working with regex",
    "text": "4 General principles for working with regex\nThe syntax is very concise, so it’s helpful to break down individual regular expressions into the component parts to understand them. As Murrell notes, since regex are their own language, it’s a good idea to build up a regex in pieces as a way of avoiding errors just as we would with any computer code. str_detect in R’s stringr and re.findall in Python are particularly useful in seeing what was matched to help in understanding and learning regular expression syntax and debugging your regex. As with many kinds of coding, I find that debugging my regex is usually what takes most of my time.",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#using-regex-in-r",
    "href": "regex.html#using-regex-in-r",
    "title": "Using regular expression in R and Python",
    "section": "5 Using regex in R",
    "text": "5 Using regex in R\nThe grep, gregexpr and gsub functions and their stringr analogs are more powerful when used with regular expressions. In the following examples, we’ll illustrate usage of stringr functions, but with their base R analogs as comments.\n\n5.1 Working with patterns\nFirst let’s see the use of character sets and character classes.\n\nlibrary(stringr)\ntext &lt;- c(\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\")\nstr_detect(text, \"[[:digit:]]\")   ## search for a digit\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n## Base R equivalent:\n## grep(\"[[:digit:]]\", text, perl = TRUE)\n\n\nstr_detect(text, \"[:,\\t.]\")   # search for various punctuation symbols\n\n[1]  TRUE  TRUE FALSE  TRUE\n\n## Base R equivalent:\n## grep(\"[:,\\t.]\", text)\n\n\nstr_locate_all(text, \"[:,\\t.]\")\n\n[[1]]\n     start end\n[1,]    17  17\n[2,]    31  31\n\n[[2]]\n     start end\n[1,]     8   8\n\n[[3]]\n     start end\n\n[[4]]\n     start end\n[1,]    16  16\n[2,]    20  20\n\n## Base R equivalent:\n## gregexpr(\"[:,\\t.]\", text)\n\n\nstr_extract_all(text, \"[[:digit:]]+\")  # extract one or more digits\n\n[[1]]\n[1] \"919\"  \"543\"  \"3300\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\n[1] \"731\"\n\n[[4]]\n[1] \"919\"  \"554\"  \"3800\"\n\n## Base R equivalent:\n## matches &lt;- gregexpr(\"[[:digit]]+\", text)\n## regmatches(text, matches)\n\n\nstr_replace_all(text, \"[[:digit:]]\", \"X\") \n\n[1] \"Here's my number: XXX-XXX-XXXX.\" \"hi John, good to meet you\"      \n[3] \"They bought XXX bananas\"         \"Please call XXX.XXX.XXXX\"       \n\n## Base R equivalent:\n## gsub(\"[[:digit:]]\", \"X\", text)\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow would we find a spam-like pattern with digits or non-letters inside a word? E.g., I want to find “V1agra” or “Fancy repl!c@ted watches”.\n\n\nNext let’s consider location-specific matches.\n\nstr_detect(text, \"^[[:upper:]]\")   # text starting with upper case letter\n\n[1]  TRUE FALSE  TRUE  TRUE\n\n## Base R equivalent:\n## grep(\"^[[:upper:]]\", text) \n\n\nstr_detect(text, \"[[:digit:]]$\")   # text ending with a digit\n\n[1] FALSE FALSE FALSE  TRUE\n\n## Base R equivalent:\n## grep(\"[[:digit:]]$\", text) \n\nNow let’s make use of repetitions.\nLet’s search for US/Canadian/Caribbean phone numbers in the example text we’ve been using:\n\ntext &lt;- c(\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\")\npattern &lt;- \"[[:digit:]]{3}[-.][[:digit:]]{3}[-.][[:digit:]]{4}\"\nstr_extract_all(text, pattern)\n\n[[1]]\n[1] \"919-543-3300\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\ncharacter(0)\n\n[[4]]\n[1] \"919.554.3800\"\n\n## Base R equivalent:\n## matches &lt;- gregexpr(pattern, text)\n## regmatches(text, matches)\n\n\n\n\n\n\n\nChallenge\n\n\n\nHow would I extract an email address from an arbitrary text string?\n\n\nNext consider grouping.\nFor example, the phone number detection problem could have been done a bit more compactly (and more generally, in case the area code is omitted or a 1 is included) as:\n\nstr_extract_all(text, \"(1[-.])?([[:digit:]]{3}[-.]){1,2}[[:digit:]]{4}\")\n\n[[1]]\n[1] \"919-543-3300\"\n\n[[2]]\ncharacter(0)\n\n[[3]]\ncharacter(0)\n\n[[4]]\n[1] \"919.554.3800\"\n\n## Base R equivalent:\n## matches &lt;- gregexpr(\"(1[-.])?([[:digit:]]{3}[-.]){1,2}[[:digit:]]{4}\", text)\n## regmatches(text, matches)\n\n\n\n\n\n\n\nChallenge\n\n\n\nThe above pattern would actually match something that is not a valid phone number. What can go wrong?\n\n\nHere’s a basic example of using grouping via parentheses with the OR operator.\n\ntext &lt;- c(\"at the site http://www.ibm.com\", \"other text\", \"ftp://ibm.com\")\nstr_locate(text, \"(http|ftp):\\\\/\\\\/\")    # http or ftp followed by ://\n\n     start end\n[1,]    13  19\n[2,]    NA  NA\n[3,]     1   6\n\n## Base R equivalent:\n## gregexpr(\"(http|ftp):\\\\/\\\\/\", text)\n\nParentheses are also used for referencing back to a detected pattern when doing a replacement. For example, here we’ll find any numbers and add underscores before and after them:\n\ntext &lt;- c(\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\")\nstr_replace_all(text, \"([0-9]+)\", \"_\\\\1_\")   # place underscores around all numbers\n\n[1] \"Here's my number: _919_-_543_-_3300_.\"\n[2] \"hi John, good to meet you\"            \n[3] \"They bought _731_ bananas\"            \n[4] \"Please call _919_._554_._3800_\"       \n\n\nHere we’ll remove commas not used as field separators.\n\ntext &lt;- ('\"H4NY07011\",\"ACKERMAN, GARY L.\",\"H\",\"$13,242\",,,')\nclean_text &lt;- str_replace_all(text, \"([^\\\",]),\", \"\\\\1\")\nclean_text\n\n[1] \"\\\"H4NY07011\\\",\\\"ACKERMAN GARY L.\\\",\\\"H\\\",\\\"$13242\\\",,,\"\n\ncat(clean_text)\n\n\"H4NY07011\",\"ACKERMAN GARY L.\",\"H\",\"$13242\",,,\n\n## Base R equivalent:\n## gsub(\"([^\\\",]),\", \"\\\\1\", text)\n\n\n\n\n\n\n\nChallenge\n\n\n\nSuppose a text string has dates in the form “Aug-3”, “May-9”, etc. and I want them in the form “3 Aug”, “9 May”, etc. How would I do this search/replace?\n\n\nFinally, let’s consider where a match ends when there is ambiguity.\nAs a simple example consider that if we try this search, we match as many digits as possible, rather than returning the first “9” as satisfying the request for “one or more” digits.\n\ntext &lt;- \"See the 998 balloons.\"\nstr_extract(text, \"[[:digit:]]+\")\n\n[1] \"998\"\n\n\nThat behavior is called greedy matching, and it’s the default. That example also shows why it is the default. What would happen if it were not the default?\nHowever, sometimes greedy matching doesn’t get us what we want.\nConsider this attempt to remove multiple html tags from a string.\n\ntext &lt;- \"Do an internship &lt;b&gt; in place &lt;/b&gt; of &lt;b&gt; one &lt;/b&gt; course.\"\nstr_replace_all(text, \"&lt;.*&gt;\", \"\")\n\n[1] \"Do an internship  course.\"\n\n## Base R equivalent:\n## gsub(\"&lt;.*&gt;\", \"\", text)\n\nNotice what happens because of greedy matching.\nOne solution is to append a ? to the repetition syntax to cause the matching to be non-greedy. Here’s an example.\n\nstr_replace_all(text, \"&lt;.*?&gt;\", \"\")\n\n[1] \"Do an internship  in place  of  one  course.\"\n\n## Base R equivalent:\n## gsub(\"&lt;.*?&gt;\", \"\", text)\n\nHowever, one can often avoid greedy matching by being more clever.\n\n\n\n\n\n\nChallenge\n\n\n\nHow could we change our regex to avoid the greedy matching without using the “?”?\n\n\n\n\n5.2 ‘Escaping’ special characters\nUsing backslashes to ‘escape’ particular characters can be tricky. One rule of thumb is to just keep adding backslashes until you get what you want!\n\n## last case here is literally a backslash and then 'n'\nstrings &lt;- c(\"Hello\", \"Hello.\", \"Hello\\nthere\", \"Hello\\\\nthere\")\ncat(strings, sep = \"\\n\")\n\nHello\nHello.\nHello\nthere\nHello\\nthere\n\n\n\nstr_detect(strings, \".\")         ## . means any character\n\n[1] TRUE TRUE TRUE TRUE\n\n## This would fail because \\. looks for the special symbol \\.\n## (which doesn't exist):\n## str_detect(strings, \"\\.\"))\n\nstr_detect(strings, \"\\\\.\")       ## \\\\ says treat \\ literally, which then escapes the .\n\n[1] FALSE  TRUE FALSE FALSE\n\nstr_detect(strings, \"\\n\")        ## \\n looks for the special symbol \\n\n\n[1] FALSE FALSE  TRUE FALSE\n\n## \\\\ says treat \\ literally, but \\ is not meaningful regex\ntry(str_detect(strings, \"\\\\\"))\n\nError in stri_detect_regex(string, pattern, negate = negate, opts_regex = opts(pattern)) : \n  Unrecognized backslash escape sequence in pattern. (U_REGEX_BAD_ESCAPE_SEQUENCE, context=`\\`)\n\n## R parser removes two \\ to give \\\\; then in regex \\\\ treats second \\ literally\nstr_detect(strings, \"\\\\\\\\\")        \n\n[1] FALSE FALSE FALSE  TRUE\n\n\n\n\n5.3 Other comments\nIf we are working with newlines embedded in a string, we can include the newline character as a regular character that is matched by a “.” by first creating the regular expression with stringr::regex with the dotall argument set to TRUE:\n\nmyex &lt;- regex(\"&lt;p&gt;.*&lt;/p&gt;\", dotall = TRUE)\nhtml_string &lt;- \"And &lt;p&gt;here is some\\ninformation&lt;/p&gt; for you.\"\nstr_extract(html_string, myex)\n\n[1] \"&lt;p&gt;here is some\\ninformation&lt;/p&gt;\"\n\n\n\nstr_extract(html_string, \"&lt;p&gt;.*&lt;/p&gt;\")   # doesn't work because \\n is not matched\n\n[1] NA\n\n\nRegular expression can be used in a variety of places. E.g., to split by any number of white space characters\n\nline &lt;- \"a dog\\tjumped\\nover \\tthe moon.\"\ncat(line)\n\na dog   jumped\nover    the moon.\n\nstr_split(line, \"[[:space:]]+\")\n\n[[1]]\n[1] \"a\"      \"dog\"    \"jumped\" \"over\"   \"the\"    \"moon.\" \n\nstr_split(line, \"[[:blank:]]+\")\n\n[[1]]\n[1] \"a\"            \"dog\"          \"jumped\\nover\" \"the\"          \"moon.\"",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "regex.html#using-regex-in-python",
    "href": "regex.html#using-regex-in-python",
    "title": "Using regular expression in R and Python",
    "section": "6 Using regex in Python",
    "text": "6 Using regex in Python\n\n6.1 Working with patterns\nFor working with regex in Python, we’ll need the re package. It provides Perl-style regular expressions, but it doesn’t seem to support named character classes such as [:digit:]. Instead use classes such as \\d and [0-9].\nAgain, in the code chunks that follow, all the explicit print statements are needed for R Markdown to print out the values.\nIn Python, you apply a matching function and then query the result to get information about what was matched and where in the string.\n\nimport re\ntext = \"Here's my number: 919-543-3300.\"\nm = re.search(\"\\d+\", text)\nm\n\n&lt;re.Match object; span=(18, 21), match='919'&gt;\n\nm.group()\n\n'919'\n\nm.start()\n\n18\n\nm.end()\n\n21\n\nm.span()\n\n(18, 21)\n\n\nNotice that that showed us only the first match.\nWe can instead use findall to get all the matches.\n\nre.findall(\"\\d+\", text)\n\n['919', '543', '3300']\n\n\nTo ignore case, do the following:\n\nimport re\nstr = \"That cat in the Hat\"\nre.findall(\"hat\", str, re.IGNORECASE)\n\n['hat', 'Hat']\n\n\nThere are several other regex flags (also called compilation flags) that can control the behavior of the matching engine in interesting ways (check out re.VERBOSE and re.MULTILINE for instance).\nWe can of course use list comprehension to work with multiple strings. But we need to be careful to check whether a match was found.\n\nimport re\ntext = [\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\"]\n\ndef return_group(pattern, txt):\n    m = re.search(pattern, txt)\n    if m:\n       return(m.group())\n    else:\n       return(None)\n\n[return_group(\"\\d+\", str) for str in text]\n\n['919', None, '731', '919']\n\n\nNext, let’s look at replacing patterns, using re.sub.\n\nimport re\ntext = [\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\"]\nre.sub(\"\\d\", \"Z\", text[0])\n\n\"Here's my number: ZZZ-ZZZ-ZZZZ.\"\n\n\nNext let’s consider grouping using ().\nHere’s a basic example of using grouping via parentheses with the OR operator (|).\n\ntext = \"At the site http://www.ibm.com. Some other text. ftp://ibm.com\"\nre.search(\"(http|ftp):\\\\/\\\\/\", text).group()\n\n'http://'\n\n\nHowever, if we want to find all the matches and try to use findall, we see that it returns only the captured groups when grouping operators are present, as discussed a bit in help(re.findall), so we’d need to add an additional grouping operator to capture the full pattern when using findall:\n\nre.findall(\"(http|ftp):\\\\/\\\\/\", text)  \n\n['http', 'ftp']\n\nre.findall(\"((http|ftp):\\\\/\\\\/)\", text)  \n\n[('http://', 'http'), ('ftp://', 'ftp')]\n\n\nWhen you are searching for all occurrences of a pattern in a large text object, it may be beneficial to use finditer:\n\nit = re.finditer(\"(http|ftp):\\\\/\\\\/\", text)  # http or ftp followed by ://\n\nfor match in it:\n    match.span()\n\n(12, 19)\n(49, 55)\n\n\nThis method behaves lazily and returns an iterator that gives us one match at a time, and only scans for the next match when we ask for it.\nGroups are also used when we need to reference back to a detected pattern when doing a replacement. This is why they are sometimes referred to as “capturing groups”. For example, here we’ll find any numbers and add underscores before and after them:\n\ntext = \"Here's my number: 919-543-3300. They bought 731 bananas. Please call 919.554.3800.\"\nre.sub(\"([0-9]+)\", \"_\\\\1_\", text)\n\n\"Here's my number: _919_-_543_-_3300_. They bought _731_ bananas. Please call _919_._554_._3800_.\"\n\n\nHere we’ll remove commas not used as field separators by replacing all commas except those occurring after another comma or after a quotation mark. This is an attempt to remove all commas not used as field delimiters.\n\ntext = '\"H4NY07011\",\"ACKERMAN, GARY L.\",\"H\",\"$13,242\",,,'\nre.sub(\"([^\\\",]),\", \"\\\\1\", text)\n\n'\"H4NY07011\",\"ACKERMAN GARY L.\",\"H\",\"$13242\",,,'\n\n\nHow does that work? Consider that “[^\\\",]” matches a character that is not a quote and not a comma. The regex is therefore such a non-quote, non-comma character followed by a comma, with the matched character saved in \\\\1 because of the grouping operator.\nGroups can also be given names, instead of having to refer to them by their numbers, but we will not demonstrate this here.\nFinally, let’s consider where a match ends when there is ambiguity.\nAs a simple example consider that if we try this search, we match as many digits as possible, rather than returning the first “9” as satisfying the request for “one or more” digits.\n\ntext = \"See the 998 balloons.\"\nre.findall(\"\\d+\", text)\n\n['998']\n\n\nThat behavior is called greedy matching, and it’s the default. That example also shows why it is the default. What would happen if it were not the default?\nHowever, sometimes greedy matching doesn’t get us what we want.\nConsider this attempt to remove multiple html tags from a string.\n\ntext = \"Do an internship &lt;b&gt; in place &lt;/b&gt; of &lt;b&gt; one &lt;/b&gt; course.\"\nre.sub(\"&lt;.*&gt;\", \"\", text)\n\n'Do an internship  course.'\n\n\nNotice what happens because of greedy matching.\nOne way to avoid greedy matching is to use a ? after the repetition specifier.\n\nre.sub(\"&lt;.*?&gt;\", \"\", text)\n\n'Do an internship  in place  of  one  course.'\n\n\nHowever, that syntax is a bit frustrating because ? is also used to indicate 0 or 1 repetitions, making the regex a bit hard to read/understand.\n\n\n\n\n\n\nChallenge\n\n\n\nSuppose I want to strip out HTML tags but without using the ? to avoid greedy matching. How can I be more careful in constructing my regex?\n\n\n\n\n6.2 ‘Escaping’ special characters\nFor reasons explained in the re documentation, to match an actual backslash, such as \"\\section\", you’d need \"\\\\\\\\section\". This can be avoided by using raw strings: r\"\\\\section\".\nHere are some more examples of escaping characters.\n\nstrings = [\"Hello\", \"Hello.\", \"Hello\\nthere\", \"Hello\\\\nthere\"]\nstrings[2]\n\n'Hello\\nthere'\n\nstrings[3]\n\n'Hello\\\\nthere'\n\nprint(strings[2])\n\nHello\nthere\n\nprint(strings[3])\n\nHello\\nthere\n\n\n\nre.search(\".\", strings[0])    ## . means any character\n\n&lt;re.Match object; span=(0, 1), match='H'&gt;\n\nre.search(\"\\.\", strings[0])   ## \\. escapes the period and treats it literally\nre.search(\"\\.\", strings[1])   ## \\. escapes the period and treats it literally\n\n&lt;re.Match object; span=(5, 6), match='.'&gt;\n\nre.search(\"\\n\", strings[2])   ## \\n looks for the special symbol \\n\n\n&lt;re.Match object; span=(5, 6), match='\\n'&gt;\n\nre.search(\"\\n\", strings[3])   ## \\n looks for the special symbol \\n\nre.search(\"\\\\\\\\\", strings[3])  ## string parser removes two \\ to give \\\\;\n                               ## then in regex \\\\ treats second \\ literally\n\n\n\n6.3 Other comments\nYou can also compile regex patterns for faster processing when working with a pattern multiple times.\n\nimport re\ntext = [\"Here's my number: 919-543-3300.\", \"hi John, good to meet you\",\n          \"They bought 731 bananas\", \"Please call 919.554.3800\"]\np = re.compile('\\d+')\nm = p.search(text[0])\nm.group()\n\n'919'",
    "crumbs": [
      "Using Regular Expressions"
    ]
  },
  {
    "objectID": "license.html",
    "href": "license.html",
    "title": "License",
    "section": "",
    "text": "This work is licensed under a Creative Commons Attribution 4.0 International License.",
    "crumbs": [
      "License"
    ]
  }
]